<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI é»˜æ›¸åŠ©æ‰‹ - Pro Version</title>
    <style>
        /* UI å„ªåŒ–æ¨£å¼ */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background-color: #f0f4f8; color: #333; }
        h1 { color: #2c3e50; text-align: center; margin-bottom: 20px; }
        
        /* æ¨¡å¼åˆ‡æ›æŒ‰éˆ• */
        .mode-switch { display: flex; justify-content: center; margin-bottom: 20px; background: #fff; padding: 10px; border-radius: 50px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .mode-label { padding: 10px 25px; cursor: pointer; border-radius: 25px; font-weight: bold; transition: 0.3s; margin: 0 5px; }
        .mode-input { display: none; }
        .mode-input:checked + .mode-label { background-color: #007bff; color: white; transform: scale(1.05); }
        
        fieldset { border: none; border-radius: 12px; padding: 25px; margin-bottom: 20px; background-color: #fff; box-shadow: 0 4px 6px rgba(0,0,0,0.05); }
        legend { font-size: 1.2em; font-weight: bold; color: #007bff; padding: 0 10px; background: #f0f4f8; border-radius: 5px; }
        
        textarea { width: 100%; min-height: 180px; padding: 15px; border: 2px solid #e0e0e0; border-radius: 8px; resize: vertical; font-size: 16px; box-sizing: border-box; transition: border-color 0.3s; }
        textarea:focus { border-color: #007bff; outline: none; }
        
        label { display: block; margin-top: 15px; font-weight: 600; color: #555; }
        input[type="range"] { width: 100%; margin: 8px 0; accent-color: #007bff; }
        small { display: block; margin-top: 5px; color: #888; font-size: 0.9em; }
        
        button { padding: 12px 20px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; margin-right: 10px; transition: all 0.2s; font-weight: bold; }
        .btn-primary { background-color: #007bff; color: white; }
        .btn-primary:hover { background-color: #0056b3; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-success:hover { background-color: #218838; }
        .btn-outline { background-color: transparent; border: 2px solid #007bff; color: #007bff; }
        .btn-outline:hover { background-color: #e7f1ff; }

        .progress-display { background-color: #fff3cd; padding: 20px; border-radius: 8px; text-align: center; margin-top: 20px; font-size: 1.2em; font-weight: bold; color: #856404; border: 1px solid #ffeeba; }

        /* éš±è—/é¡¯ç¤ºæ§åˆ¶ */
        .vocab-only { display: block; }
        .passage-only { display: none; }
    </style>
</head>
<body>

    <h1>ğŸ“ AI é»˜æ›¸åŠ©æ‰‹ (Pro)</h1>

    <div class="mode-switch">
        <input type="radio" id="modeVocab" name="dictationMode" class="mode-input" checked onchange="switchMode('vocab')">
        <label for="modeVocab" class="mode-label">ğŸ è©èªæ¨¡å¼ (Vocabulary)</label>

        <input type="radio" id="modePassage" name="dictationMode" class="mode-input" onchange="switchMode('passage')">
        <label for="modePassage" class="mode-label">ğŸ“– èª²æ–‡æ¨¡å¼ (Passage)</label>
    </div>

    <fieldset>
        <legend>1. è¼¸å…¥å…§å®¹</legend>
        <textarea id="wordInput" placeholder="åœ¨æ­¤è¼¸å…¥è©èª..."></textarea>
        
        <div style="margin-top: 15px;">
            <button onclick="clearInput()" class="btn-outline">æ¸…ç©º</button>
            <button onclick="document.getElementById('fileUpload').click()" class="btn-primary">ä¸Šè¼‰æ–‡ä»¶</button>
            <input type="file" id="fileUpload" accept=".txt,.pdf,.jpg,.png" style="display: none;">
            
            <span id="shuffleContainer" class="vocab-only" style="display:inline-block; margin-left: 10px;">
                <label style="display:inline; cursor:pointer;">
                    <input type="checkbox" id="shuffleWords"> ğŸ² æ‰“äº‚é †åº (Shuffle)
                </label>
            </span>
        </div>
    </fieldset>

    <fieldset>
        <legend>2. è¨­å®š</legend>

        <label>ğŸ—£ï¸ èªè¨€ (Language):</label>
        <select id="languageSelect" style="padding: 8px; border-radius: 4px; width: 100%;">
            <option value="zh-HK">Cantonese (HK) ğŸ‡­ğŸ‡° - å»£æ±è©±</option>
            <option value="en-US">English (US) ğŸ‡ºğŸ‡¸</option>
            <option value="en-GB">English (UK) ğŸ‡¬ğŸ‡§</option>
            <option value="zh-CN">Mandarin (CN) ğŸ‡¨ğŸ‡³ - æ™®é€šè©±</option>
        </select>

        <label>ğŸ¢ èªé€Ÿ (Speed): <span id="rateValue">1.0x</span></label>
        <input type="range" id="rateSlider" min="0.5" max="1.5" step="0.1" value="0.9" oninput="document.getElementById('rateValue').innerText = this.value + 'x'">

        <label>â³ é–“éš” (Gap): <span id="gapValue">5 ç§’</span></label>
        <input type="range" id="gapSlider" min="1" max="15" step="1" value="5" oninput="document.getElementById('gapValue').innerText = this.value + ' ç§’'">

        <label>ğŸ” é‡è¤‡æ¬¡æ•¸ (Repeat): <span id="repeatCountValue">2 æ¬¡</span></label>
        <input type="range" id="repeatCountSlider" min="1" max="5" step="1" value="2" oninput="document.getElementById('repeatCountValue').innerText = this.value + ' æ¬¡'">

        <label>
            <input type="checkbox" id="readPunctuation" checked>
            **è®€å‡ºæ¨™é»ç¬¦è™Ÿ** (Read Punctuation)
        </label>
        <small id="punctHint">å‹¾é¸å¾Œï¼Œæœƒå°‡ã€Œï¼Œã€è®€ä½œã€Œé€—è™Ÿã€ï¼Œã€Œã€‚ã€è®€ä½œã€Œå¥è™Ÿã€ç­‰ã€‚</small>
    </fieldset>
    
    <fieldset>
        <legend>3. é–‹å§‹</legend>
        <div class="main-controls">
            <button id="startButton" class="btn-success">â–¶ï¸ é–‹å§‹é»˜æ›¸</button>
            <button id="pauseButton" class="btn-primary" disabled>â¸ï¸ æš«åœ</button>
            <button id="resetButton" class="btn-outline" disabled>ğŸ”„ é‡ç½®</button>
        </div>
        <div class="progress-display">æº–å‚™å°±ç·’</div>
    </fieldset>

    <script>
        // è®Šæ•¸åˆå§‹åŒ–
        const wordInput = document.getElementById('wordInput');
        const languageSelect = document.getElementById('languageSelect');
        const rateSlider = document.getElementById('rateSlider');
        const gapSlider = document.getElementById('gapSlider');
        const repeatCountSlider = document.getElementById('repeatCountSlider');
        const readPunctuation = document.getElementById('readPunctuation');
        const shuffleWords = document.getElementById('shuffleWords');
        
        const startButton = document.getElementById('startButton');
        const pauseButton = document.getElementById('pauseButton');
        const resetButton = document.getElementById('resetButton');
        const progressDisplay = document.querySelector('.progress-display');
        const shuffleContainer = document.getElementById('shuffleContainer');

        let wordsArray = [];
        let currentIndex = 0;
        let isPaused = false;
        let currentTimeout = null;
        let availableVoices = [];
        let currentMode = 'vocab'; // 'vocab' or 'passage'
        const synth = window.speechSynthesis;

        // --- æ¨¡å¼åˆ‡æ›é‚è¼¯ ---
        window.switchMode = function(mode) {
            currentMode = mode;
            const inputArea = document.getElementById('wordInput');
            
            if (mode === 'vocab') {
                inputArea.placeholder = "ã€è©èªæ¨¡å¼ã€‘\nè«‹è¼¸å…¥è©èªï¼Œç”¨ Enter æˆ– é€—è™Ÿ åˆ†éš”ã€‚\nä¾‹å¦‚ï¼š\nè˜‹æœ\næ©™\né¦™è•‰";
                shuffleContainer.style.display = 'inline-block';
                rateSlider.value = 1.0; document.getElementById('rateValue').innerText = '1.0x';
            } else {
                inputArea.placeholder = "ã€èª²æ–‡æ¨¡å¼ã€‘\nè«‹ç›´æ¥è²¼ä¸Šæ•´æ®µèª²æ–‡ã€‚\nç¨‹å¼æœƒè‡ªå‹•æ ¹æ“šæ¨™é»ç¬¦è™Ÿ (ï¼Œã€‚ï¼Ÿï¼) åˆ‡åˆ†æˆçŸ­å¥æœ—è®€ã€‚";
                shuffleContainer.style.display = 'none';
                rateSlider.value = 0.8; document.getElementById('rateValue').innerText = '0.8x'; // èª²æ–‡é»˜èªæ…¢ä¸€é»
            }
        }
        // åˆå§‹åŒ–æç¤º
        switchMode('vocab');

        // --- æ¨™é»ç¬¦è™Ÿè½‰æ›è¡¨ ---
        const punctuationMap = {
            'ï¼Œ': 'é€—è™Ÿ', ',': 'Comma',
            'ã€‚': 'å¥è™Ÿ', '.': 'Full stop',
            'ï¼Ÿ': 'å•è™Ÿ', '?': 'Question mark',
            'ï¼': 'æ„Ÿå˜†è™Ÿ', '!': 'Exclamation mark',
            'ï¼š': 'å†’è™Ÿ', ':': 'Colon',
            'ã€Œ': 'é–‹å¼•è™Ÿ', 'ã€': 'é—œå¼•è™Ÿ',
            'â€œ': 'Open quote', 'â€': 'Close quote'
        };

        // --- æ ¸å¿ƒåŠŸèƒ½ ---

        function clearInput() { wordInput.value = ''; }

        // èªéŸ³åŠ è¼‰
        function populateVoices() { availableVoices = synth.getVoices(); }
        if (synth.onvoiceschanged !== undefined) synth.onvoiceschanged = populateVoices;
        setTimeout(populateVoices, 1000);

        // è™•ç†è¼¸å…¥æ–‡å­— (æ ¸å¿ƒè®Šæ›´)
        function prepareWords() {
            let text = wordInput.value.trim();
            if (!text) return false;

            if (currentMode === 'vocab') {
                // 1. è©èªæ¨¡å¼ï¼šç”¨æ›è¡Œæˆ–é€—è™Ÿåˆ†å‰²
                wordsArray = text.split(/[\n\r,ï¼Œ]+/).map(w => w.trim()).filter(w => w.length > 0);
                
                // æ‰“äº‚é †åºåŠŸèƒ½
                if (shuffleWords.checked) {
                    wordsArray.sort(() => Math.random() - 0.5);
                }

            } else {
                // 2. èª²æ–‡æ¨¡å¼ï¼šæ™ºèƒ½æ–·å¥ (ä¿ç•™æ¨™é»åœ¨å¥å°¾)
                // æ­£å‰‡è§£é‡‹ï¼šä¾æ“šæ¨™é»åˆ†å‰²ï¼Œä½†ä¿ç•™æ¨™é»
                // é‚è¼¯ï¼šå°‡æ–‡ç« åˆ‡åˆ†æˆ "çŸ­èª+æ¨™é»" çš„çµ„åˆ
                
                // å…ˆå°‡æ›è¡Œç¬¦è½‰ç‚ºç©ºæ ¼ï¼Œé¿å…æ–·è¡Œé€ æˆèª¤è®€
                text = text.replace(/[\n\r]+/g, ' ');
                
                // ç°¡å–®æ–·å¥ï¼šä¾æ“šæ¨™é»ç¬¦è™Ÿåˆ‡åˆ†
                // ä½¿ç”¨æ­£å‰‡ capture group è®“ split ä¿ç•™åˆ†éš”ç¬¦ï¼Œç„¶å¾Œå†åˆä½µ
                let rawParts = text.split(/([ï¼Œ,ã€‚.\?ï¼Ÿ!ï¼;ï¼›ï¼š:])/);
                
                wordsArray = [];
                for (let i = 0; i < rawParts.length; i += 2) {
                    let sentence = rawParts[i];
                    let punct = rawParts[i+1] || ""; // ç²å–å°æ‡‰çš„æ¨™é»
                    
                    if (sentence.trim().length > 0 || punct.length > 0) {
                         // å°‡æ–‡å­—å’Œæ¨™é»çµ„åˆåœ¨ä¸€èµ·ä½œç‚ºä¸€å€‹é»˜æ›¸å–®ä½
                         wordsArray.push(sentence + punct);
                    }
                }
            }
            
            currentIndex = 0;
            isPaused = false;
            return true;
        }

        // æœ—è®€å–®å€‹é …ç›® (å«é‡è¤‡é‚è¼¯)
        function speakItem(text, repeatCount, currentRep) {
            if (isPaused) return;

            let textToRead = text;

            // è™•ç†æ¨™é»è®€éŸ³
            if (readPunctuation.checked) {
                // éæ­·å­—å…¸æ›¿æ›ç¬¦è™Ÿç‚ºæ–‡å­—
                for (let symbol in punctuationMap) {
                    textToRead = textToRead.split(symbol).join(" " + punctuationMap[symbol] + " ");
                }
            } else {
                // å¦‚æœä¸è®€æ¨™é»ï¼Œç‚ºäº†èªéŸ³æµæš¢ï¼Œå¯ä»¥æš«æ™‚ä¿ç•™ç¬¦è™Ÿè®“ AI åœé “ï¼Œæˆ–è€…ä¸è™•ç†
                // é€™è£¡ä¿æŒåŸæ¨£ï¼ŒTTS å¼•æ“é€šå¸¸æœƒå°æ¨™é»åšåœé “è™•ç†
            }

            const utterance = new SpeechSynthesisUtterance(textToRead);
            utterance.rate = parseFloat(rateSlider.value);
            utterance.lang = languageSelect.value;
            
            // é¸æ“‡æœ€ä½³èªéŸ³
            if (availableVoices.length > 0) {
                const targetLang = languageSelect.value;
                // å„ªå…ˆæ‰¾å°æ‡‰èªè¨€çš„èªéŸ³
                const voice = availableVoices.find(v => v.lang === targetLang && !v.name.includes('Google')) || availableVoices.find(v => v.lang === targetLang);
                if (voice) utterance.voice = voice;
            }

            // æ›´æ–°é¡¯ç¤º
            progressDisplay.innerText = `ğŸ“¢ [${currentIndex + 1}/${wordsArray.length}] ${text} (ç¬¬ ${currentRep} æ¬¡)`;
            
            utterance.onend = () => {
                if (currentRep < repeatCount) {
                    // é‡è¤‡æœ—è®€ä¹‹é–“çš„çŸ­é–“éš” (å›ºå®š 2 ç§’)
                    currentTimeout = setTimeout(() => {
                        speakItem(text, repeatCount, currentRep + 1);
                    }, 2000);
                } else {
                    // å®Œæˆæ‰€æœ‰é‡è¤‡ï¼Œé€²å…¥ä¸‹ä¸€å€‹è©
                    const mainGap = parseFloat(gapSlider.value) * 1000;
                    currentTimeout = setTimeout(nextItem, mainGap);
                }
            };

            utterance.onerror = (e) => {
                console.error("Speech Error", e);
                // å‡ºéŒ¯ä¹Ÿå˜—è©¦ç¹¼çºŒ
                currentTimeout = setTimeout(nextItem, 2000);
            };

            synth.speak(utterance);
        }

        function nextItem() {
            if (currentIndex >= wordsArray.length) {
                progressDisplay.innerText = "ğŸ‰ é»˜æ›¸å®Œæˆï¼";
                resetControls(true);
                return;
            }
            if (isPaused) return;

            const itemText = wordsArray[currentIndex];
            const repeats = parseInt(repeatCountSlider.value);
            
            speakItem(itemText, repeats, 1);
            currentIndex++;
        }

        // --- æŒ‰éˆ•äº‹ä»¶ ---
        startButton.onclick = () => {
            if (synth.speaking || isPaused) return;
            synth.cancel();

            if (!prepareWords()) {
                alert("è«‹å…ˆè¼¸å…¥å…§å®¹ï¼");
                return;
            }

            startButton.disabled = true;
            pauseButton.disabled = false;
            resetButton.disabled = false;
            startButton.innerText = "é€²è¡Œä¸­...";
            
            nextItem();
        };

        pauseButton.onclick = () => {
            if (isPaused) {
                isPaused = false;
                synth.resume();
                pauseButton.innerText = "â¸ï¸ æš«åœ";
                // æ¢å¾©é‚è¼¯éœ€è¦å°å¿ƒï¼Œç°¡å–®èµ·è¦‹ï¼Œå¦‚æœæ˜¯å› ç‚ºé–“éš”æœŸé–“æš«åœï¼Œæ¢å¾©æ™‚ç›´æ¥è®€ä¸‹ä¸€å€‹
                if (!synth.speaking) nextItem();
            } else {
                isPaused = true;
                synth.pause();
                clearTimeout(currentTimeout);
                pauseButton.innerText = "â–¶ï¸ ç¹¼çºŒ";
                progressDisplay.innerText += " (å·²æš«åœ)";
            }
        };

        function resetControls(finished) {
            clearTimeout(currentTimeout);
            synth.cancel();
            isPaused = false;
            startButton.disabled = false;
            startButton.innerText = "â–¶ï¸ é–‹å§‹é»˜æ›¸";
            pauseButton.disabled = true;
            resetButton.disabled = true;
            pauseButton.innerText = "â¸ï¸ æš«åœ";
            if (!finished) progressDisplay.innerText = "æº–å‚™å°±ç·’";
        }

        resetButton.onclick = () => resetControls(false);

        // é é¢åŠ è¼‰æ™‚åŸ·è¡Œä¸€æ¬¡æ¨¡å¼è¨­å®š
        switchMode('vocab');
    </script>
</body>
</html>
