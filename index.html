<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI é»˜æ›¸åŠ©æ‰‹ V4.0</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background-color: #f0f4f8; color: #333; }
        h1 { color: #2c3e50; text-align: center; margin-bottom: 20px; }
        
        /* æ¨¡å¼åˆ‡æ› */
        .mode-switch { display: flex; justify-content: center; margin-bottom: 20px; background: #fff; padding: 10px; border-radius: 50px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .mode-label { padding: 10px 25px; cursor: pointer; border-radius: 25px; font-weight: bold; transition: 0.3s; margin: 0 5px; }
        .mode-input { display: none; }
        .mode-input:checked + .mode-label { background-color: #007bff; color: white; transform: scale(1.05); }
        
        fieldset { border: none; border-radius: 12px; padding: 25px; margin-bottom: 20px; background-color: #fff; box-shadow: 0 4px 6px rgba(0,0,0,0.05); }
        legend { font-size: 1.2em; font-weight: bold; color: #007bff; padding: 0 10px; background: #f0f4f8; border-radius: 5px; }
        
        textarea { width: 100%; min-height: 180px; padding: 15px; border: 2px solid #e0e0e0; border-radius: 8px; resize: vertical; font-size: 16px; box-sizing: border-box; }
        textarea:focus { border-color: #007bff; outline: none; }
        
        label { display: block; margin-top: 15px; font-weight: 600; color: #555; }
        input[type="range"] { width: 100%; margin: 8px 0; accent-color: #007bff; cursor: pointer; }
        small { display: block; margin-top: 5px; color: #888; font-size: 0.9em; }
        
        button { padding: 12px 20px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; margin-right: 10px; font-weight: bold; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-primary { background-color: #007bff; color: white; }
        .btn-outline { background-color: transparent; border: 2px solid #007bff; color: #007bff; }
        button:disabled { background-color: #ccc; cursor: not-allowed; border-color: #ccc; color: #666; }

        .progress-display { background-color: #fff3cd; padding: 20px; border-radius: 8px; text-align: center; margin-top: 20px; font-size: 1.2em; font-weight: bold; color: #856404; border: 1px solid #ffeeba; }
        
        /* æ§åˆ¶é¡¯ç¤º */
        .vocab-only { display: block; }
    </style>
</head>
<body>

    <h1>ğŸ“ AI é»˜æ›¸åŠ©æ‰‹ V4.0</h1>

    <div class="mode-switch">
        <input type="radio" id="modeVocab" name="dictationMode" class="mode-input" checked onchange="switchMode('vocab')">
        <label for="modeVocab" class="mode-label">ğŸ è©èªæ¨¡å¼</label>

        <input type="radio" id="modePassage" name="dictationMode" class="mode-input" onchange="switchMode('passage')">
        <label for="modePassage" class="mode-label">ğŸ“– èª²æ–‡æ¨¡å¼</label>
    </div>

    <fieldset>
        <legend>1. è¼¸å…¥å…§å®¹</legend>
        <textarea id="wordInput" placeholder="åœ¨æ­¤è¼¸å…¥..."></textarea>
        <div style="margin-top: 15px;">
            <button onclick="clearInput()" class="btn-outline">æ¸…ç©º</button>
            <span id="shuffleContainer" class="vocab-only" style="display:inline-block; margin-left: 10px;">
                <label style="display:inline; cursor:pointer;">
                    <input type="checkbox" id="shuffleWords"> ğŸ² æ‰“äº‚é †åº
                </label>
            </span>
        </div>
    </fieldset>

    <fieldset>
        <legend>2. è¨­å®š</legend>
        <label>ğŸ—£ï¸ èªè¨€:</label>
        <select id="languageSelect" style="padding: 8px; width: 100%;">
            <option value="zh-HK">å»£æ±è©± (Cantonese)</option>
            <option value="en-US">English (US)</option>
            <option value="en-GB">English (UK)</option>
            <option value="zh-CN">æ™®é€šè©±</option>
        </select>

        <label>ğŸ¢ èªé€Ÿ (Speed): <span id="rateValue">0.8x</span></label>
        <input type="range" id="rateSlider" min="0.2" max="1.5" step="0.1" value="0.8" oninput="document.getElementById('rateValue').innerText = this.value + 'x'">

        <label>â³ é¡Œç›®é–“éš” (Gap): <span id="gapValue">5 ç§’</span></label>
        <input type="range" id="gapSlider" min="1" max="15" step="1" value="5" oninput="document.getElementById('gapValue').innerText = this.value + ' ç§’'">

        <label>ğŸ” é‡è¤‡æ¬¡æ•¸ (Repeat): <span id="repeatCountValue">2 æ¬¡</span></label>
        <input type="range" id="repeatCountSlider" min="1" max="5" step="1" value="2" oninput="document.getElementById('repeatCountValue').innerText = this.value + ' æ¬¡'">

        <label>
            <input type="checkbox" id="readPunctuation" checked>
            **è®€å‡ºæ¨™é»ç¬¦è™Ÿ**
        </label>
        <small>å‹¾é¸å¾Œï¼Œæœƒè®€å‡ºã€Œé€—è™Ÿã€ã€ã€Œå¥è™Ÿã€ï¼Œä¸¦æœƒåœ¨ç¬¦è™Ÿå‰å¢åŠ åœé “ã€‚</small>
    </fieldset>
    
    <fieldset>
        <legend>3. é–‹å§‹</legend>
        <div class="main-controls">
            <button id="startButton" class="btn-success">â–¶ï¸ é–‹å§‹</button>
            <button id="pauseButton" class="btn-primary" disabled>â¸ï¸ æš«åœ</button>
            <button id="resetButton" class="btn-outline" disabled>ğŸ”„ é‡ç½®</button>
        </div>
        <div class="progress-display">æº–å‚™å°±ç·’</div>
    </fieldset>

    <script>
        // --- è®Šæ•¸å€ ---
        const wordInput = document.getElementById('wordInput');
        const languageSelect = document.getElementById('languageSelect');
        const rateSlider = document.getElementById('rateSlider');
        const gapSlider = document.getElementById('gapSlider');
        const repeatCountSlider = document.getElementById('repeatCountSlider');
        const readPunctuation = document.getElementById('readPunctuation');
        const shuffleWords = document.getElementById('shuffleWords');
        
        const startButton = document.getElementById('startButton');
        const pauseButton = document.getElementById('pauseButton');
        const resetButton = document.getElementById('resetButton');
        const progressDisplay = document.querySelector('.progress-display');
        const shuffleContainer = document.getElementById('shuffleContainer');

        let wordsArray = [];
        let currentIndex = 0;
        let currentRepeatsDone = 0; // æ–°å¢ï¼šè¨˜éŒ„ç•¶å‰é€™å€‹å­—å·²ç¶“è®€äº†å¹¾æ¬¡
        let isPaused = false;
        let timer = null; // çµ±ä¸€è¨ˆæ™‚å™¨
        let availableVoices = [];
        let currentMode = 'vocab'; 
        const synth = window.speechSynthesis;

        // --- æ¨™é»ç¬¦è™Ÿè¡¨ (ä¿®æ”¹ï¼šåŠ å…¥åœé “ç¬¦è™Ÿ) ---
        // ä½¿ç”¨ "..." æˆ– ". . ." ä¾†å¼·åˆ¶ TTS å¼•æ“åœé “
        const PAUSE_MARKER = " . . . "; 
        const punctuationMap = {
            'ï¼Œ': PAUSE_MARKER + 'é€—è™Ÿ', ',': PAUSE_MARKER + 'Comma',
            'ã€‚': PAUSE_MARKER + 'å¥è™Ÿ', '.': PAUSE_MARKER + 'Full stop',
            'ï¼Ÿ': PAUSE_MARKER + 'å•è™Ÿ', '?': PAUSE_MARKER + 'Question mark',
            'ï¼': PAUSE_MARKER + 'æ„Ÿå˜†è™Ÿ', '!': PAUSE_MARKER + 'Exclamation mark',
            'ï¼š': PAUSE_MARKER + 'å†’è™Ÿ', ':': PAUSE_MARKER + 'Colon',
            'ã€Œ': PAUSE_MARKER + 'é–‹å¼•è™Ÿ', 'ã€': PAUSE_MARKER + 'é—œå¼•è™Ÿ',
            'â€œ': PAUSE_MARKER + 'Open quote', 'â€': PAUSE_MARKER + 'Close quote'
        };

        // --- åˆå§‹åŒ– & æ¨¡å¼ ---
        function populateVoices() { availableVoices = synth.getVoices(); }
        if (synth.onvoiceschanged !== undefined) synth.onvoiceschanged = populateVoices;
        setTimeout(populateVoices, 1000);

        window.switchMode = function(mode) {
            currentMode = mode;
            if (mode === 'vocab') {
                wordInput.placeholder = "ã€è©èªæ¨¡å¼ã€‘\nè¼¸å…¥è©èªï¼Œç”¨ Enter åˆ†éš”ã€‚\n(ä¾‹å¦‚ï¼šè˜‹æœ\næ©™)";
                shuffleContainer.style.display = 'inline-block';
                rateSlider.value = 0.8; document.getElementById('rateValue').innerText = '0.8x';
            } else {
                wordInput.placeholder = "ã€èª²æ–‡æ¨¡å¼ã€‘\nè²¼ä¸Šæ•´æ®µèª²æ–‡ã€‚\nç¨‹å¼æœƒè‡ªå‹•ä¾æ¨™é»åˆ‡åˆ†ï¼Œä¸¦åœ¨è®€æ¨™é»å‰åœé “ã€‚";
                shuffleContainer.style.display = 'none';
                rateSlider.value = 0.6; document.getElementById('rateValue').innerText = '0.6x';
            }
        }
        switchMode('vocab');
        function clearInput() { wordInput.value = ''; }

        // --- æ ¸å¿ƒé‚è¼¯ï¼šæº–å‚™æ–‡å­— ---
        function prepareWords() {
            let text = wordInput.value.trim();
            if (!text) return false;

            if (currentMode === 'vocab') {
                wordsArray = text.split(/[\n\r,ï¼Œ]+/).map(w => w.trim()).filter(w => w.length > 0);
                if (shuffleWords.checked) wordsArray.sort(() => Math.random() - 0.5);
            } else {
                // èª²æ–‡æ¨¡å¼ï¼šåˆ‡åˆ†å¥å­ä¸¦ä¿ç•™æ¨™é»
                text = text.replace(/[\n\r]+/g, ' ');
                // é‚è¼¯ï¼šåˆ‡åˆ†å¾Œï¼Œå¶æ•¸æ˜¯æ–‡å­—ï¼Œå¥‡æ•¸æ˜¯æ¨™é»
                let rawParts = text.split(/([ï¼Œ,ã€‚.\?ï¼Ÿ!ï¼;ï¼›ï¼š:])/);
                wordsArray = [];
                for (let i = 0; i < rawParts.length; i += 2) {
                    let sentence = rawParts[i].trim();
                    let punct = rawParts[i+1] || "";
                    if (sentence || punct) {
                        wordsArray.push({ text: sentence, punct: punct });
                    }
                }
            }
            // é‡ç½®è¨ˆæ•¸
            currentIndex = 0;
            currentRepeatsDone = 0; 
            isPaused = false;
            return true;
        }

        // --- æ ¸å¿ƒé‚è¼¯ï¼šæœ—è®€ ---
        function playCurrentItem() {
            if (isPaused) return;

            // æª¢æŸ¥æ˜¯å¦çµæŸ
            if (currentIndex >= wordsArray.length) {
                progressDisplay.innerText = "ğŸ‰ é»˜æ›¸å®Œæˆï¼";
                resetControls(true);
                return;
            }

            // ç²å–ç•¶å‰å…§å®¹
            let item = wordsArray[currentIndex];
            let textToRead = "";
            let displayString = "";

            if (currentMode === 'vocab') {
                // è©èªæ¨¡å¼
                textToRead = item;
                displayString = item;
            } else {
                // èª²æ–‡æ¨¡å¼ (Object: {text, punct})
                let pText = item.text;
                let pMark = item.punct;
                
                // é¡¯ç¤ºæ–‡å­—
                displayString = pText + pMark;

                // çµ„åˆæœ—è®€æ–‡å­—
                if (readPunctuation.checked && punctuationMap[pMark]) {
                    // å¦‚æœè¦è®€æ¨™é»ï¼šå¥å­ + å¼·åˆ¶åœé “ + æ¨™é»å
                    textToRead = pText + punctuationMap[pMark]; 
                } else {
                    // å¦‚æœä¸è®€æ¨™é»ï¼Œåªè®€æ–‡å­—ï¼Œä½†åŠ ä¸Šæ¨™é»ç¬¦è™Ÿè®“èªéŸ³å¼•æ“è‡ªç„¶åœé “
                    textToRead = pText + pMark; 
                }
            }

            // è®€å‡ºæ¬¡æ•¸é™åˆ¶
            const totalRepeats = parseInt(repeatCountSlider.value);

            // æ›´æ–°ç•«é¢
            progressDisplay.innerText = `ğŸ“¢ [${currentIndex + 1}/${wordsArray.length}] ${displayString}\n(ç¬¬ ${currentRepeatsDone + 1} æ¬¡ / å…± ${totalRepeats} æ¬¡)`;

            // å»ºç«‹èªéŸ³
            const utterance = new SpeechSynthesisUtterance(textToRead);
            utterance.rate = parseFloat(rateSlider.value);
            utterance.lang = languageSelect.value;
            
            // èªéŸ³é¸æ“‡å„ªåŒ–
            if (availableVoices.length > 0) {
                const targetLang = languageSelect.value;
                const voice = availableVoices.find(v => v.lang === targetLang && !v.name.includes('Google')) || availableVoices.find(v => v.lang === targetLang);
                if (voice) utterance.voice = voice;
            }

            // --- æœ—è®€çµæŸå¾Œçš„è™•ç† (é—œéµé‚è¼¯) ---
            utterance.onend = () => {
                if (isPaused) return; // å¦‚æœåœ¨è®€çš„éç¨‹ä¸­æŒ‰äº†æš«åœï¼Œè®€å®Œé€™å¥å°±åœï¼Œä¸åŸ·è¡Œ timeout

                currentRepeatsDone++; // å®Œæˆäº†ä¸€æ¬¡

                if (currentRepeatsDone < totalRepeats) {
                    // é‚„æ²’è®€å¤ æ¬¡æ•¸ï¼Œä¼‘æ¯ 2 ç§’å¾Œé‡è®€é€™å¥
                    timer = setTimeout(() => {
                        playCurrentItem(); // éæ­¸èª¿ç”¨ï¼Œè®€åŒä¸€å€‹ index
                    }, 2000);
                } else {
                    // é€™å¥è®€å¤ äº†ï¼Œé‡ç½®é‡è¤‡æ¬¡æ•¸ï¼Œé€²å…¥ä¸‹ä¸€å¥
                    currentRepeatsDone = 0;
                    currentIndex++;
                    const mainGap = parseFloat(gapSlider.value) * 1000;
                    timer = setTimeout(playCurrentItem, mainGap);
                }
            };

            utterance.onerror = (e) => {
                console.error("Speech Error", e);
                // éŒ¯èª¤è™•ç†ï¼šå˜—è©¦è·³ä¸‹ä¸€é¡Œ
                if(!isPaused) {
                    timer = setTimeout(() => {
                        currentIndex++;
                        currentRepeatsDone = 0;
                        playCurrentItem();
                    }, 1000);
                }
            };

            synth.cancel(); // ä¿éšªèµ·è¦‹
            synth.speak(utterance);
        }

        // --- æŒ‰éˆ•æ§åˆ¶ (ä¿®å¾©æš«åœå•é¡Œ) ---
        
        startButton.onclick = () => {
            if (synth.speaking && !isPaused) return;
            
            // å…¨æ–°é–‹å§‹
            if (!prepareWords()) { alert("è«‹å…ˆè¼¸å…¥å…§å®¹ï¼"); return; }
            
            isPaused = false;
            updateBtnState("running");
            playCurrentItem();
        };

        pauseButton.onclick = () => {
            if (isPaused) {
                // === æŒ‰ä¸‹ã€Œç¹¼çºŒã€ ===
                isPaused = false;
                updateBtnState("running");
                // é‡æ–°è§¸ç™¼ç•¶å‰ç‹€æ…‹ (ä¸æœƒè·³é¡Œï¼Œå› ç‚º currentIndex å’Œ currentRepeatsDone æ²’è®Š)
                playCurrentItem();
            } else {
                // === æŒ‰ä¸‹ã€Œæš«åœã€ ===
                isPaused = true;
                synth.cancel(); // ç«‹å³åœæ­¢ç™¼è²
                clearTimeout(timer); // æ¸…é™¤æ‰€æœ‰å€’æ•¸
                updateBtnState("paused");
                progressDisplay.innerText += "\nğŸ›‘ å·²æš«åœ (æŒ‰ç¹¼çºŒä»¥é‡è®€æ­¤å¥)";
            }
        };

        resetButton.onclick = () => resetControls(false);

        function resetControls(finished) {
            clearTimeout(timer);
            synth.cancel();
            isPaused = false;
            currentIndex = 0;
            currentRepeatsDone = 0;
            updateBtnState("reset");
            if (!finished) progressDisplay.innerText = "æº–å‚™å°±ç·’";
        }

        function updateBtnState(state) {
            if (state === "running") {
                startButton.disabled = true;
                pauseButton.disabled = false;
                pauseButton.innerText = "â¸ï¸ æš«åœ";
                resetButton.disabled = false;
            } else if (state === "paused") {
                pauseButton.innerText = "â–¶ï¸ ç¹¼çºŒ";
            } else {
                // reset
                startButton.disabled = false;
                pauseButton.disabled = true;
                pauseButton.innerText = "â¸ï¸ æš«åœ";
                resetButton.disabled = true;
            }
        }
    </script>
</body>
</html>
